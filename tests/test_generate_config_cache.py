"""Tests for generate-config-cache.py."""

from __future__ import annotations

import importlib.util
import subprocess
import sys
import textwrap
from pathlib import Path

import pytest

# ---------------------------------------------------------------------------
# Import the module under test (it has a hyphenated filename, so we use
# importlib to load it).
# ---------------------------------------------------------------------------
ROOT = Path(__file__).resolve().parent.parent
SCRIPT = ROOT / "generate-config-cache.py"
FIXTURES = Path(__file__).resolve().parent / "fixtures"
SAMPLE_TOML = FIXTURES / "sample-toolkit.toml"
ADVERSARIAL_TOML = FIXTURES / "adversarial-toolkit.toml"


def _load_module():
    spec = importlib.util.spec_from_file_location("generate_config_cache", SCRIPT)
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)
    return mod


mod = _load_module()
generate_cache = mod.generate_cache
validate_schema = mod.validate_schema
flatten = mod.flatten
SCHEMA = mod.SCHEMA


# ===================================================================
# Basic TOML -> env conversion
# ===================================================================


class TestBasicConversion:
    def test_sample_toml_generates_output(self):
        output = generate_cache(SAMPLE_TOML)
        assert output.startswith("# Auto-generated by generate-config-cache.py")
        assert "TOOLKIT_PROJECT_NAME='my-project'" in output

    def test_output_has_trailing_newline(self):
        output = generate_cache(SAMPLE_TOML)
        assert output.endswith("\n")

    def test_output_contains_header_comment(self):
        output = generate_cache(SAMPLE_TOML)
        assert "# Source:" in output

    def test_adversarial_toml_generates_output(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "TOOLKIT_PROJECT_NAME=" in output


# ===================================================================
# Nested key flattening
# ===================================================================


class TestKeyFlattening:
    def test_top_level_key(self):
        output = generate_cache(SAMPLE_TOML)
        assert "TOOLKIT_TOOLKIT_REMOTE_URL=" in output

    def test_nested_key(self):
        output = generate_cache(SAMPLE_TOML)
        assert "TOOLKIT_HOOKS_SETUP_PYTHON_MIN_VERSION='3.11'" in output

    def test_deeply_nested_key(self):
        output = generate_cache(SAMPLE_TOML)
        assert "TOOLKIT_HOOKS_POST_EDIT_LINT_LINTERS_PY_CMD=" in output

    def test_hyphens_become_underscores(self):
        output = generate_cache(SAMPLE_TOML)
        # "post-edit-lint" -> "POST_EDIT_LINT"
        assert "POST_EDIT_LINT" in output
        assert "post-edit-lint" not in output.split("\n", 3)[-1]  # not in var names

    def test_keys_are_uppercased(self):
        output = generate_cache(SAMPLE_TOML)
        for line in output.split("\n"):
            if line.startswith("TOOLKIT_"):
                key = line.split("=", 1)[0]
                assert key == key.upper(), f"Key not uppercase: {key}"


# ===================================================================
# Array -> JSON string conversion
# ===================================================================


class TestArrayConversion:
    def test_string_array(self):
        output = generate_cache(SAMPLE_TOML)
        assert 'TOOLKIT_HOOKS_SETUP_REQUIRED_TOOLS=\'["ruff","jq"]\'' in output

    def test_multi_element_array(self):
        output = generate_cache(SAMPLE_TOML)
        assert 'TOOLKIT_PROJECT_STACKS=\'["python","ios"]\'' in output

    def test_empty_array(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "TOOLKIT_PROJECT_STACKS='[]'" in output
        assert "TOOLKIT_HOOKS_SETUP_REQUIRED_TOOLS='[]'" in output

    def test_arrays_are_compact_json(self):
        """Arrays should use compact JSON (no spaces after separators)."""
        output = generate_cache(SAMPLE_TOML)
        # Find the line with REQUIRED_TOOLS
        for line in output.split("\n"):
            if "REQUIRED_TOOLS=" in line:
                val = line.split("=", 1)[1]
                # Should not have spaces after commas or colons
                assert ", " not in val
                break


# ===================================================================
# Special characters in values
# ===================================================================


class TestSpecialCharacters:
    def test_single_quotes_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # The project name has single quotes; they must be escaped
        assert "project with spaces" in output
        # Verify the line is valid shell by checking the escaping
        for line in output.split("\n"):
            if "TOOLKIT_PROJECT_NAME=" in line:
                # Should use '\'' escaping for single quotes
                assert "'\\''" in line
                break

    def test_dollar_sign_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # critical_rules contains "$VARIABLE" — must be single-quoted
        assert "$VARIABLE" in output

    def test_backticks_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "`backticks`" in output

    def test_double_quotes_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # The JSON array will contain escaped double quotes inside single quotes
        assert '\\"double quotes\\"' in output

    def test_unicode_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # Unicode should pass through (cafe with combining accent, snowman, heart)
        assert "caf" in output  # at minimum the ascii part

    def test_pipe_and_ampersand_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "pipes | stuff" in output

    def test_glob_patterns_in_values(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "*/src/**/*.py" in output


# ===================================================================
# Schema validation
# ===================================================================


class TestSchemaValidation:
    def test_valid_config_passes(self):
        import tomllib

        with open(SAMPLE_TOML, "rb") as f:
            data = tomllib.load(f)
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_adversarial_config_passes(self):
        import tomllib

        with open(ADVERSARIAL_TOML, "rb") as f:
            data = tomllib.load(f)
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_unknown_top_level_key_rejected(self):
        data = {"unknown_section": {"foo": "bar"}}
        errors = validate_schema(data, SCHEMA)
        assert len(errors) == 1
        assert "Unknown key" in errors[0]
        assert "unknown_section" in errors[0]

    def test_unknown_nested_key_rejected(self):
        data = {"project": {"name": "test", "unknown_key": "bad"}}
        errors = validate_schema(data, SCHEMA)
        assert len(errors) == 1
        assert "unknown_key" in errors[0]

    def test_unknown_hook_section_rejected(self):
        data = {"hooks": {"nonexistent": {"foo": "bar"}}}
        errors = validate_schema(data, SCHEMA)
        assert len(errors) == 1
        assert "nonexistent" in errors[0]

    def test_dynamic_keys_in_linters_accepted(self):
        """Linter extension keys (py, ts, etc.) are dynamic and should be accepted."""
        data = {
            "hooks": {
                "post-edit-lint": {
                    "linters": {
                        "py": {"cmd": "ruff check", "fmt": "ruff format"},
                        "ts": {"cmd": "eslint"},
                        "custom_ext": {"cmd": "custom-lint"},
                    }
                }
            }
        }
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_dynamic_keys_in_gates_accepted(self):
        """Gate names are dynamic and should be accepted."""
        data = {
            "hooks": {
                "task-completed": {
                    "gates": {
                        "lint": {"glob": "*.py", "cmd": "ruff"},
                        "custom_gate": {"glob": "*.rs", "cmd": "cargo check"},
                    }
                }
            }
        }
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_generate_cache_raises_on_invalid_schema(self, tmp_path):
        bad_toml = tmp_path / "bad.toml"
        bad_toml.write_text('[bad_section]\nfoo = "bar"\n')
        with pytest.raises(ValueError, match="Schema validation failed"):
            generate_cache(bad_toml)


# ===================================================================
# Missing optional sections
# ===================================================================


class TestMissingSections:
    def test_minimal_config(self, tmp_path):
        """A TOML with only [project] should work fine."""
        minimal = tmp_path / "minimal.toml"
        minimal.write_text('[project]\nname = "minimal"\n')
        output = generate_cache(minimal)
        assert "TOOLKIT_PROJECT_NAME='minimal'" in output

    def test_empty_config(self, tmp_path):
        """A completely empty TOML should produce just headers."""
        empty = tmp_path / "empty.toml"
        empty.write_text("")
        output = generate_cache(empty)
        assert "# Auto-generated" in output
        # Should have only header lines and a trailing newline
        non_comment = [
            l for l in output.strip().split("\n") if l and not l.startswith("#")
        ]
        assert len(non_comment) == 0


# ===================================================================
# Flatten function unit tests
# ===================================================================


class TestFlatten:
    def test_simple_dict(self):
        result = flatten({"name": "test"}, "PRE")
        assert result == [("PRE_NAME", "'test'")]

    def test_nested_dict(self):
        result = flatten({"a": {"b": "c"}}, "PRE")
        assert result == [("PRE_A_B", "'c'")]

    def test_list_value(self):
        result = flatten({"items": ["x", "y"]}, "PRE")
        assert result == [("PRE_ITEMS", '\'["x","y"]\'')]

    def test_empty_list(self):
        result = flatten({"items": []}, "PRE")
        assert result == [("PRE_ITEMS", "'[]'")]

    def test_integer_value(self):
        result = flatten({"count": 42}, "PRE")
        assert result == [("PRE_COUNT", "'42'")]

    def test_boolean_value(self):
        result = flatten({"enabled": True}, "PRE")
        assert result == [("PRE_ENABLED", "'true'")]

    def test_hyphen_to_underscore(self):
        result = flatten({"my-key": "val"}, "PRE")
        assert result[0][0] == "PRE_MY_KEY"


# ===================================================================
# CLI integration tests
# ===================================================================


class TestCLI:
    def test_validate_only_valid(self):
        result = subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--validate-only",
                "--toml",
                str(SAMPLE_TOML),
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert "Valid" in result.stdout

    def test_validate_only_invalid(self, tmp_path):
        bad = tmp_path / "bad.toml"
        bad.write_text('[wrong_section]\nkey = "val"\n')
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--validate-only", "--toml", str(bad)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        assert "Unknown key" in result.stderr

    def test_output_to_file(self, tmp_path):
        out = tmp_path / "cache.env"
        result = subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert out.exists()
        content = out.read_text()
        assert "TOOLKIT_PROJECT_NAME=" in content

    def test_output_to_stdout(self):
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--toml", str(SAMPLE_TOML)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert "TOOLKIT_PROJECT_NAME=" in result.stdout

    def test_missing_toml_file(self):
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--toml", "/nonexistent/path.toml"],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        assert "not found" in result.stderr

    def test_invalid_toml_syntax(self, tmp_path):
        bad = tmp_path / "bad.toml"
        bad.write_text("this is not valid [[[ toml")
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--toml", str(bad)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        # Error message varies by Python version; just check it reports something
        assert result.stderr.strip() != ""


# ===================================================================
# Shell sourcing integration test
# ===================================================================


class TestShellIntegration:
    def test_generated_env_is_sourceable(self, tmp_path):
        """The generated cache file should be valid bash that can be sourced."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        # Source the file in bash and read back a value
        result = subprocess.run(
            ["bash", "-c", f'source "{out}" && echo "$TOOLKIT_PROJECT_NAME"'],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert result.stdout.strip() == "my-project"

    def test_adversarial_env_is_sourceable(self, tmp_path):
        """Even adversarial values should produce valid bash."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(ADVERSARIAL_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        # Source the file — just check it doesn't error
        result = subprocess.run(
            ["bash", "-c", f'source "{out}" && echo "$TOOLKIT_PROJECT_NAME"'],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert "project with spaces" in result.stdout

    def test_dollar_not_expanded(self, tmp_path):
        """Single-quoted values must prevent shell expansion of $VARIABLE."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(ADVERSARIAL_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        result = subprocess.run(
            [
                "bash",
                "-c",
                f'source "{out}" && echo "$TOOLKIT_HOOKS_SUBAGENT_CONTEXT_STACK_INFO"',
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        # $pecial should NOT be expanded (it should be literal)
        assert "$pecial" in result.stdout

    def test_json_array_parseable_by_jq(self, tmp_path):
        """JSON arrays in env vars should be parseable by jq."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        result = subprocess.run(
            [
                "bash",
                "-c",
                f'source "{out}" && echo "$TOOLKIT_HOOKS_SETUP_REQUIRED_TOOLS" | jq -r ".[]"',
            ],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:  # jq might not be installed in CI
            lines = result.stdout.strip().split("\n")
            assert "ruff" in lines
            assert "jq" in lines
