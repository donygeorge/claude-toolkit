"""Tests for generate-config-cache.py."""

from __future__ import annotations

import importlib.util
import subprocess
import sys
import textwrap
from pathlib import Path

import pytest

# ---------------------------------------------------------------------------
# Import the module under test (it has a hyphenated filename, so we use
# importlib to load it).
# ---------------------------------------------------------------------------
ROOT = Path(__file__).resolve().parent.parent
SCRIPT = ROOT / "generate-config-cache.py"
FIXTURES = Path(__file__).resolve().parent / "fixtures"
SAMPLE_TOML = FIXTURES / "sample-toolkit.toml"
ADVERSARIAL_TOML = FIXTURES / "adversarial-toolkit.toml"


def _load_module():
    spec = importlib.util.spec_from_file_location("generate_config_cache", SCRIPT)
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)
    return mod


mod = _load_module()
generate_cache = mod.generate_cache
validate_schema = mod.validate_schema
flatten = mod.flatten
SCHEMA = mod.SCHEMA
ENUM_VALUES = mod.ENUM_VALUES
_validate_env_key = mod._validate_env_key
_check_control_chars = mod._check_control_chars
_validate_enum_values = mod._validate_enum_values


# ===================================================================
# Basic TOML -> env conversion
# ===================================================================


class TestBasicConversion:
    def test_sample_toml_generates_output(self):
        output = generate_cache(SAMPLE_TOML)
        assert output.startswith("# Auto-generated by generate-config-cache.py")
        assert "TOOLKIT_PROJECT_NAME='my-project'" in output

    def test_output_has_trailing_newline(self):
        output = generate_cache(SAMPLE_TOML)
        assert output.endswith("\n")

    def test_output_contains_header_comment(self):
        output = generate_cache(SAMPLE_TOML)
        assert "# Source:" in output

    def test_adversarial_toml_generates_output(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "TOOLKIT_PROJECT_NAME=" in output


# ===================================================================
# Nested key flattening
# ===================================================================


class TestKeyFlattening:
    def test_top_level_key(self):
        output = generate_cache(SAMPLE_TOML)
        assert "TOOLKIT_TOOLKIT_REMOTE_URL=" in output

    def test_nested_key(self):
        output = generate_cache(SAMPLE_TOML)
        assert "TOOLKIT_HOOKS_SETUP_PYTHON_MIN_VERSION='3.11'" in output

    def test_deeply_nested_key(self):
        output = generate_cache(SAMPLE_TOML)
        assert "TOOLKIT_HOOKS_POST_EDIT_LINT_LINTERS_PY_CMD=" in output

    def test_hyphens_become_underscores(self):
        output = generate_cache(SAMPLE_TOML)
        # "post-edit-lint" -> "POST_EDIT_LINT"
        assert "POST_EDIT_LINT" in output
        assert "post-edit-lint" not in output.split("\n", 3)[-1]  # not in var names

    def test_keys_are_uppercased(self):
        output = generate_cache(SAMPLE_TOML)
        for line in output.split("\n"):
            if line.startswith("TOOLKIT_"):
                key = line.split("=", 1)[0]
                assert key == key.upper(), f"Key not uppercase: {key}"


# ===================================================================
# Array -> JSON string conversion
# ===================================================================


class TestArrayConversion:
    def test_string_array(self):
        output = generate_cache(SAMPLE_TOML)
        assert 'TOOLKIT_HOOKS_SETUP_REQUIRED_TOOLS=\'["ruff","jq"]\'' in output

    def test_multi_element_array(self):
        output = generate_cache(SAMPLE_TOML)
        assert 'TOOLKIT_PROJECT_STACKS=\'["python","ios"]\'' in output

    def test_empty_array(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "TOOLKIT_PROJECT_STACKS='[]'" in output
        assert "TOOLKIT_HOOKS_SETUP_REQUIRED_TOOLS='[]'" in output

    def test_arrays_are_compact_json(self):
        """Arrays should use compact JSON (no spaces after separators)."""
        output = generate_cache(SAMPLE_TOML)
        # Find the line with REQUIRED_TOOLS
        for line in output.split("\n"):
            if "REQUIRED_TOOLS=" in line:
                val = line.split("=", 1)[1]
                # Should not have spaces after commas or colons
                assert ", " not in val
                break


# ===================================================================
# Special characters in values
# ===================================================================


class TestSpecialCharacters:
    def test_single_quotes_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # The project name has single quotes; they must be escaped
        assert "project with spaces" in output
        # Verify the line is valid shell by checking the escaping
        for line in output.split("\n"):
            if "TOOLKIT_PROJECT_NAME=" in line:
                # Should use '\'' escaping for single quotes
                assert "'\\''" in line
                break

    def test_dollar_sign_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # critical_rules contains "$VARIABLE" — must be single-quoted
        assert "$VARIABLE" in output

    def test_backticks_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "`backticks`" in output

    def test_double_quotes_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # The JSON array will contain escaped double quotes inside single quotes
        assert '\\"double quotes\\"' in output

    def test_unicode_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        # Unicode should pass through (cafe with combining accent, snowman, heart)
        assert "caf" in output  # at minimum the ascii part

    def test_pipe_and_ampersand_in_value(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "pipes | stuff" in output

    def test_glob_patterns_in_values(self):
        output = generate_cache(ADVERSARIAL_TOML)
        assert "*/src/**/*.py" in output


# ===================================================================
# Schema validation
# ===================================================================


class TestSchemaValidation:
    def test_valid_config_passes(self):
        import tomllib

        with open(SAMPLE_TOML, "rb") as f:
            data = tomllib.load(f)
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_adversarial_config_passes(self):
        import tomllib

        with open(ADVERSARIAL_TOML, "rb") as f:
            data = tomllib.load(f)
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_unknown_top_level_key_rejected(self):
        data = {"unknown_section": {"foo": "bar"}}
        errors = validate_schema(data, SCHEMA)
        assert len(errors) == 1
        assert "Unknown key" in errors[0]
        assert "unknown_section" in errors[0]

    def test_unknown_nested_key_rejected(self):
        data = {"project": {"name": "test", "unknown_key": "bad"}}
        errors = validate_schema(data, SCHEMA)
        assert len(errors) == 1
        assert "unknown_key" in errors[0]

    def test_unknown_hook_section_rejected(self):
        data = {"hooks": {"nonexistent": {"foo": "bar"}}}
        errors = validate_schema(data, SCHEMA)
        assert len(errors) == 1
        assert "nonexistent" in errors[0]

    def test_dynamic_keys_in_linters_accepted(self):
        """Linter extension keys (py, ts, etc.) are dynamic and should be accepted."""
        data = {
            "hooks": {
                "post-edit-lint": {
                    "linters": {
                        "py": {"cmd": "ruff check", "fmt": "ruff format"},
                        "ts": {"cmd": "eslint"},
                        "custom_ext": {"cmd": "custom-lint"},
                    }
                }
            }
        }
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_dynamic_keys_in_gates_accepted(self):
        """Gate names are dynamic and should be accepted."""
        data = {
            "hooks": {
                "task-completed": {
                    "gates": {
                        "lint": {"glob": "*.py", "cmd": "ruff"},
                        "custom_gate": {"glob": "*.rs", "cmd": "cargo check"},
                    }
                }
            }
        }
        errors = validate_schema(data, SCHEMA)
        assert errors == []

    def test_generate_cache_raises_on_invalid_schema(self, tmp_path):
        bad_toml = tmp_path / "bad.toml"
        bad_toml.write_text('[bad_section]\nfoo = "bar"\n')
        with pytest.raises(ValueError, match="Schema validation failed"):
            generate_cache(bad_toml)


# ===================================================================
# Missing optional sections
# ===================================================================


class TestMissingSections:
    def test_minimal_config(self, tmp_path):
        """A TOML with only [project] should work fine."""
        minimal = tmp_path / "minimal.toml"
        minimal.write_text('[project]\nname = "minimal"\n')
        output = generate_cache(minimal)
        assert "TOOLKIT_PROJECT_NAME='minimal'" in output

    def test_empty_config(self, tmp_path):
        """A completely empty TOML should produce just headers."""
        empty = tmp_path / "empty.toml"
        empty.write_text("")
        output = generate_cache(empty)
        assert "# Auto-generated" in output
        # Should have only header lines and a trailing newline
        non_comment = [
            l for l in output.strip().split("\n") if l and not l.startswith("#")
        ]
        assert len(non_comment) == 0


# ===================================================================
# Flatten function unit tests
# ===================================================================


class TestFlatten:
    def test_simple_dict(self):
        result = flatten({"name": "test"}, "PRE")
        assert result == [("PRE_NAME", "'test'")]

    def test_nested_dict(self):
        result = flatten({"a": {"b": "c"}}, "PRE")
        assert result == [("PRE_A_B", "'c'")]

    def test_list_value(self):
        result = flatten({"items": ["x", "y"]}, "PRE")
        assert result == [("PRE_ITEMS", '\'["x","y"]\'')]

    def test_empty_list(self):
        result = flatten({"items": []}, "PRE")
        assert result == [("PRE_ITEMS", "'[]'")]

    def test_integer_value(self):
        result = flatten({"count": 42}, "PRE")
        assert result == [("PRE_COUNT", "'42'")]

    def test_boolean_value(self):
        result = flatten({"enabled": True}, "PRE")
        assert result == [("PRE_ENABLED", "'true'")]

    def test_hyphen_to_underscore(self):
        result = flatten({"my-key": "val"}, "PRE")
        assert result[0][0] == "PRE_MY_KEY"


# ===================================================================
# CLI integration tests
# ===================================================================


class TestCLI:
    def test_validate_only_valid(self):
        result = subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--validate-only",
                "--toml",
                str(SAMPLE_TOML),
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert "Valid" in result.stdout

    def test_validate_only_invalid(self, tmp_path):
        bad = tmp_path / "bad.toml"
        bad.write_text('[wrong_section]\nkey = "val"\n')
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--validate-only", "--toml", str(bad)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        assert "Unknown key" in result.stderr

    def test_output_to_file(self, tmp_path):
        out = tmp_path / "cache.env"
        result = subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert out.exists()
        content = out.read_text()
        assert "TOOLKIT_PROJECT_NAME=" in content

    def test_output_to_stdout(self):
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--toml", str(SAMPLE_TOML)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert "TOOLKIT_PROJECT_NAME=" in result.stdout

    def test_missing_toml_file(self):
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--toml", "/nonexistent/path.toml"],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        assert "not found" in result.stderr

    def test_invalid_toml_syntax(self, tmp_path):
        bad = tmp_path / "bad.toml"
        bad.write_text("this is not valid [[[ toml")
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--toml", str(bad)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        # Error message varies by Python version; just check it reports something
        assert result.stderr.strip() != ""


# ===================================================================
# Shell sourcing integration test
# ===================================================================


class TestShellIntegration:
    def test_generated_env_is_sourceable(self, tmp_path):
        """The generated cache file should be valid bash that can be sourced."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        # Source the file in bash and read back a value
        result = subprocess.run(
            ["bash", "-c", f'source "{out}" && echo "$TOOLKIT_PROJECT_NAME"'],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert result.stdout.strip() == "my-project"

    def test_adversarial_env_is_sourceable(self, tmp_path):
        """Even adversarial values should produce valid bash."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(ADVERSARIAL_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        # Source the file — just check it doesn't error
        result = subprocess.run(
            ["bash", "-c", f'source "{out}" && echo "$TOOLKIT_PROJECT_NAME"'],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert "project with spaces" in result.stdout

    def test_dollar_not_expanded(self, tmp_path):
        """Single-quoted values must prevent shell expansion of $VARIABLE."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(ADVERSARIAL_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        result = subprocess.run(
            [
                "bash",
                "-c",
                f'source "{out}" && echo "$TOOLKIT_HOOKS_SUBAGENT_CONTEXT_STACK_INFO"',
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        # $pecial should NOT be expanded (it should be literal)
        assert "$pecial" in result.stdout

    def test_json_array_parseable_by_jq(self, tmp_path):
        """JSON arrays in env vars should be parseable by jq."""
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            check=True,
        )
        result = subprocess.run(
            [
                "bash",
                "-c",
                f'source "{out}" && echo "$TOOLKIT_HOOKS_SETUP_REQUIRED_TOOLS" | jq -r ".[]"',
            ],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:  # jq might not be installed in CI
            lines = result.stdout.strip().split("\n")
            assert "ruff" in lines
            assert "jq" in lines


# ===================================================================
# Security: env var name validation (M2)
# ===================================================================


class TestEnvKeyValidation:
    """Tests for _validate_env_key — rejects unsafe bash variable names."""

    def test_valid_key(self):
        assert _validate_env_key("TOOLKIT_PROJECT_NAME") is True

    def test_valid_key_with_numbers(self):
        assert _validate_env_key("TOOLKIT_V2_SETTING") is True

    def test_valid_key_starts_with_underscore(self):
        assert _validate_env_key("_INTERNAL") is True

    def test_rejects_lowercase(self):
        assert _validate_env_key("toolkit_lower") is False

    def test_rejects_hyphen(self):
        assert _validate_env_key("TOOLKIT-BAD") is False

    def test_rejects_space(self):
        assert _validate_env_key("TOOLKIT BAD") is False

    def test_rejects_starts_with_number(self):
        assert _validate_env_key("1BAD") is False

    def test_rejects_empty(self):
        assert _validate_env_key("") is False

    def test_rejects_special_chars(self):
        assert _validate_env_key("TOOLKIT$INJECT") is False

    def test_rejects_semicolon_injection(self):
        assert _validate_env_key("TOOLKIT;echo") is False

    def test_rejects_equals_injection(self):
        assert _validate_env_key("TOOLKIT=BAD") is False

    def test_rejects_backtick_injection(self):
        assert _validate_env_key("TOOLKIT`cmd`") is False


# ===================================================================
# Security: control character rejection (M2)
# ===================================================================


class TestControlCharRejection:
    """Tests for _check_control_chars — rejects dangerous control characters."""

    def test_normal_string_passes(self):
        assert _check_control_chars("hello world", "TEST") is None

    def test_newline_allowed(self):
        assert _check_control_chars("line1\nline2", "TEST") is None

    def test_tab_allowed(self):
        assert _check_control_chars("col1\tcol2", "TEST") is None

    def test_null_byte_rejected(self):
        result = _check_control_chars("bad\x00value", "TEST")
        assert result is not None
        assert "0x00" in result

    def test_bell_rejected(self):
        result = _check_control_chars("bad\x07value", "TEST")
        assert result is not None
        assert "0x07" in result

    def test_backspace_rejected(self):
        result = _check_control_chars("bad\x08value", "TEST")
        assert result is not None
        assert "0x08" in result

    def test_vertical_tab_rejected(self):
        result = _check_control_chars("bad\x0bvalue", "TEST")
        assert result is not None
        assert "0x0b" in result

    def test_form_feed_rejected(self):
        result = _check_control_chars("bad\x0cvalue", "TEST")
        assert result is not None
        assert "0x0c" in result

    def test_carriage_return_rejected(self):
        """CR (0x0d) can be used for log injection attacks."""
        result = _check_control_chars("bad\x0dvalue", "TEST")
        assert result is not None
        assert "0x0d" in result

    def test_shift_out_rejected(self):
        result = _check_control_chars("bad\x0evalue", "TEST")
        assert result is not None

    def test_escape_char_rejected(self):
        result = _check_control_chars("bad\x1bvalue", "TEST")
        assert result is not None
        assert "0x1b" in result

    def test_delete_char_rejected(self):
        result = _check_control_chars("bad\x7fvalue", "TEST")
        assert result is not None
        assert "0x7f" in result

    def test_unicode_passes(self):
        assert _check_control_chars("caf\u00e9 \u2603", "TEST") is None


# ===================================================================
# Security: TOML key injection via flatten (M2)
# ===================================================================


class TestKeyInjection:
    """Tests that TOML keys producing invalid bash var names are rejected."""

    def test_key_with_semicolon_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"bad;key": "val"})

    def test_key_with_space_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"bad key": "val"})

    def test_key_with_equals_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"bad=key": "val"})

    def test_key_with_backtick_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"`cmd`": "val"})

    def test_key_with_dollar_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"$HOME": "val"})

    def test_key_with_dot_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"bad.key": "val"})

    def test_control_char_in_string_value_rejected(self):
        with pytest.raises(ValueError, match="control character"):
            flatten({"name": "bad\x00value"})

    def test_control_char_in_list_element_rejected(self):
        with pytest.raises(ValueError, match="control character"):
            flatten({"items": ["good", "bad\x07value"]})

    def test_control_char_in_toml_value_rejected(self, tmp_path):
        """Full pipeline: TOML with control char in value should fail."""
        bad_toml = tmp_path / "ctrl.toml"
        # Write binary to include a null byte in a value
        bad_toml.write_bytes(b'[project]\nname = "bad\\x00value"\n')
        # The TOML parser will handle escape or reject — this tests the pipeline
        # For an actual control char injection, we'd need raw bytes:
        # This particular test validates the TOML parse + flatten pipeline
        try:
            generate_cache(bad_toml)
        except (ValueError, Exception):
            pass  # Expected — either TOML parse error or our validation catches it

    def test_normal_hyphenated_key_accepted(self):
        """Hyphens in TOML keys are converted to underscores — should work."""
        result = flatten({"my-key": "val"})
        assert result[0][0] == "TOOLKIT_MY_KEY"

    def test_nested_injection_rejected(self):
        with pytest.raises(ValueError, match="Unsafe variable name"):
            flatten({"ok": {"bad;key": "val"}})


# ===================================================================
# Security: TOML type validation (M2)
# ===================================================================


class TestTypeValidation:
    """Tests that validate_schema catches type mismatches."""

    def test_string_field_rejects_int(self):
        data = {"project": {"name": 42}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected string" in e for e in errors)

    def test_string_field_rejects_list(self):
        data = {"project": {"name": ["not", "a", "string"]}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected string" in e for e in errors)

    def test_string_field_rejects_bool(self):
        data = {"project": {"name": True}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected string" in e for e in errors)

    def test_int_field_rejects_string(self):
        data = {"hooks": {"session-end": {"agent_memory_max_lines": "not_an_int"}}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected integer" in e for e in errors)

    def test_int_field_rejects_bool(self):
        data = {"hooks": {"session-end": {"agent_memory_max_lines": True}}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected integer" in e for e in errors)

    def test_list_field_rejects_string(self):
        data = {"project": {"stacks": "not_a_list"}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected list" in e for e in errors)

    def test_list_field_rejects_int(self):
        data = {"project": {"stacks": 42}}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected list" in e for e in errors)

    def test_table_field_rejects_string(self):
        data = {"hooks": "not_a_table"}
        errors = validate_schema(data, SCHEMA)
        assert any("Expected table" in e for e in errors)

    def test_valid_types_pass(self):
        data = {
            "project": {"name": "test", "stacks": ["python"]},
            "hooks": {"session-end": {"agent_memory_max_lines": 100}},
        }
        errors = validate_schema(data, SCHEMA)
        assert errors == []


# ===================================================================
# Security: file permissions for output (M2)
# ===================================================================


class TestFilePermissions:
    def test_output_file_has_restrictive_permissions(self, tmp_path):
        """Generated cache file should have 0600 permissions."""
        import os
        import stat

        out = tmp_path / "cache.env"
        result = subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(SAMPLE_TOML),
                "--output",
                str(out),
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        mode = os.stat(out).st_mode
        # Check only user permissions (owner read+write, no group/other)
        assert mode & stat.S_IRUSR  # owner read
        assert mode & stat.S_IWUSR  # owner write
        assert not (mode & stat.S_IRGRP)  # no group read
        assert not (mode & stat.S_IWGRP)  # no group write
        assert not (mode & stat.S_IROTH)  # no other read
        assert not (mode & stat.S_IWOTH)  # no other write


# ===================================================================
# TDD enforcement config key (M4)
# ===================================================================


class TestTddEnforcementConfig:
    """Tests for the skills.implement.tdd_enforcement config key."""

    def test_schema_has_skills_implement_tdd_enforcement(self):
        """SCHEMA must include skills.implement.tdd_enforcement as str."""
        assert "skills" in SCHEMA
        assert "implement" in SCHEMA["skills"]
        assert "tdd_enforcement" in SCHEMA["skills"]["implement"]
        assert SCHEMA["skills"]["implement"]["tdd_enforcement"] is str

    def test_enum_values_defined(self):
        """ENUM_VALUES must list the 3 valid tdd_enforcement values."""
        key = "skills.implement.tdd_enforcement"
        assert key in ENUM_VALUES
        assert set(ENUM_VALUES[key]) == {"strict", "guided", "off"}

    def test_valid_value_strict(self, tmp_path):
        """tdd_enforcement = 'strict' should be accepted."""
        toml_file = tmp_path / "valid.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "strict"\n'
        )
        output = generate_cache(toml_file)
        assert "TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT='strict'" in output

    def test_valid_value_guided(self, tmp_path):
        """tdd_enforcement = 'guided' should be accepted."""
        toml_file = tmp_path / "valid.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "guided"\n'
        )
        output = generate_cache(toml_file)
        assert "TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT='guided'" in output

    def test_valid_value_off(self, tmp_path):
        """tdd_enforcement = 'off' should be accepted."""
        toml_file = tmp_path / "valid.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "off"\n'
        )
        output = generate_cache(toml_file)
        assert "TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT='off'" in output

    def test_invalid_value_rejected(self, tmp_path):
        """tdd_enforcement = 'always' should be rejected with a clear error."""
        toml_file = tmp_path / "invalid.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "always"\n'
        )
        with pytest.raises(ValueError, match="Invalid value.*tdd_enforcement.*always"):
            generate_cache(toml_file)

    def test_invalid_value_error_lists_allowed(self, tmp_path):
        """Rejection error message should list valid values."""
        toml_file = tmp_path / "invalid.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "bad"\n'
        )
        with pytest.raises(ValueError, match="strict.*guided.*off"):
            generate_cache(toml_file)

    def test_generated_env_var_name(self, tmp_path):
        """The generated env var must be TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT."""
        toml_file = tmp_path / "envvar.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "off"\n'
        )
        output = generate_cache(toml_file)
        assert "TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT=" in output

    def test_default_when_section_missing(self, tmp_path):
        """Config without [skills.implement] should work (backward compatible)."""
        toml_file = tmp_path / "minimal.toml"
        toml_file.write_text('[project]\nname = "test"\n')
        output = generate_cache(toml_file)
        # No TOOLKIT_SKILLS line should appear (not set in TOML)
        assert "TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT" not in output

    def test_backward_compatible_no_skills_section(self, tmp_path):
        """Existing TOML files without [skills] should still generate valid output."""
        toml_file = tmp_path / "legacy.toml"
        toml_file.write_text(textwrap.dedent("""\
            [project]
            name = "legacy-project"
            stacks = ["python"]

            [hooks.setup]
            python_min_version = "3.11"
            required_tools = ["ruff"]
        """))
        output = generate_cache(toml_file)
        assert "TOOLKIT_PROJECT_NAME='legacy-project'" in output
        # No error, no skills-related line
        assert "TOOLKIT_SKILLS" not in output

    def test_validate_enum_values_accepts_valid(self):
        """_validate_enum_values returns no errors for valid enum values."""
        data = {"skills": {"implement": {"tdd_enforcement": "strict"}}}
        errors = _validate_enum_values(data)
        assert errors == []

    def test_validate_enum_values_rejects_invalid(self):
        """_validate_enum_values returns error for invalid enum values."""
        data = {"skills": {"implement": {"tdd_enforcement": "never"}}}
        errors = _validate_enum_values(data)
        assert len(errors) == 1
        assert "never" in errors[0]
        assert "tdd_enforcement" in errors[0]

    def test_validate_only_cli_rejects_invalid_enum(self, tmp_path):
        """CLI --validate-only should reject invalid enum values."""
        bad = tmp_path / "bad_enum.toml"
        bad.write_text('[skills.implement]\ntdd_enforcement = "always"\n')
        result = subprocess.run(
            [sys.executable, str(SCRIPT), "--validate-only", "--toml", str(bad)],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 1
        assert "Invalid value" in result.stderr

    def test_sourceable_tdd_value(self, tmp_path):
        """Generated cache with tdd_enforcement should be valid bash."""
        toml_file = tmp_path / "tdd.toml"
        toml_file.write_text(
            '[skills.implement]\ntdd_enforcement = "strict"\n'
        )
        out = tmp_path / "cache.env"
        subprocess.run(
            [
                sys.executable,
                str(SCRIPT),
                "--toml",
                str(toml_file),
                "--output",
                str(out),
            ],
            check=True,
        )
        result = subprocess.run(
            [
                "bash",
                "-c",
                f'source "{out}" && echo "$TOOLKIT_SKILLS_IMPLEMENT_TDD_ENFORCEMENT"',
            ],
            capture_output=True,
            text=True,
        )
        assert result.returncode == 0
        assert result.stdout.strip() == "strict"
